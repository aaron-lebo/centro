#!/bin/sh
#| CL-LAUNCH 4.1.4 CONFIGURATION
LISP_CONTENT=
SOFTWARE_SYSTEM=
SOFTWARE_INIT_FORMS=
SOFTWARE_FINAL_FORMS=
SOURCE_REGISTRY=
INCLUDE_PATH=
LISPS="sbcl ccl clisp abcl cmucl ecl mkcl allegro lispworks scl gcl xcl"
WRAPPER_CODE=
DUMP=
RESTART="(lambda()(main uiop:*command-line-arguments*))"
IMAGE_BASE=
IMAGE_DIR=
IMAGE=
# END OF CL-LAUNCH CONFIGURATION

# This file was generated by cl-launch 4.1.4
# This file was automatically generated and contains parts of CL-Launch
#
# Please send your improvements to the author:
# fare at tunes dot org < http://www.cliki.net/Fare%20Rideau >.
#
# cl-launch is available under the terms of the bugroff license.
#       http://tunes.org/legalese/bugroff.html
# You may at your leisure use the MIT license instead < http://opensource.org/licenses/MIT >
#
# This software can be used in conjunction with any other software:
# the result may consist in pieces of the two software glued together in
# a same file, but even then these pieces remain well distinguished, and are
# each available under its own copyright and licensing terms, as applicable.
# The parts that come from the other software are subject to the terms of use
# and distribution relative to said software, which may well be
# more restrictive than the terms of this software (according to lawyers
# and the armed henchmen they got the taxpayers to pay to enforce their laws).
# The bits of code generated by cl-launch, however, remain available
# under the terms of their own license, and you may service them as you wish:
# manually, using cl-launch --update or whichever means you prefer.
# That said, if you believe in any of that intellectual property scam,
# you may be subject to the terms of my End-Seller License:
#       http://www.livejournal.com/users/fare/21806.html
#
PROG="$0"
# cl-launch 4.1.4 shell wrapper
#   Find and execute the most appropriate supported Lisp implementation
#   to evaluate software prepared with cl-launch.
#
ECHOn () { printf '%s' "$*" ;}
simple_term_p () {
  case "$1" in *[!a-zA-Z0-9-+_,.:=%/]*) return 1 ;; *) return 0 ;; esac
}
if [ -n "$BASH_VERSION$ZSH_VERSION" ] ; then
  kwote0 () { a="${1//\\/\\\\}" ; a="${a//\`/\\\`}" ; a="${a//\$/\\\$}" ; printf %s "${a//\"/\\\"}" ;}
else
  kwote0 () { ECHOn "$1" | sed -e "s/\([\\\\\"\$\`]\)/\\\\\\1/g" ;}
fi
kwote () { if simple_term_p "$1" ; then ECHOn "$1" ; else kwote0 "$1" ; fi ;}
load_form_0 () { echo "(cl:load $1 :verbose nil :print nil)" ;}
load_form () { load_form_0 "\"$(kwote "$1")\"" ;}
ECHO () { printf '%s\n' "$*" ;}
DBG () { ECHO "$*" >& 2 ;}
abort () { ERR="$1" ; shift ; DBG "$*" ; exit "$ERR" ;}
ABORT () { abort 42 "$*" ;}
DO_LISP=do_exec_lisp
HASH_BANG_FORM='(set-dispatch-macro-character #\# #\! (lambda(stream char arg)(declare(ignore char arg))(values(read-line stream))))'
PACKAGE_FORM="#.(progn(defpackage :uiop/image (:use :cl))())#.(progn(declaim (special uiop/image::*command-line-arguments*))())"
MAYBE_PACKAGE_FORM=
PROGN="(progn"
NGORP=")"

#implementation_foo () {
#  implementation "${foo:-foo}" || return 1
#  OPTIONS=${FOO_OPTIONS:- --option-to-hush-the-banner --option-to-avoid-user-init-script}
#  EVAL=--option-to-pass-a-form-to-Lisp
#  ENDARGS="--option-to-end-Lisp-arguments-and-start-user-arguments"
#  IMAGE_ARG="--option-to-specify-an-image" # "EXECUTABLE_IMAGE" if instead of foo --core x.core you just ./x.core
#  EXEC_LISP=exec_lisp # or some other thing
#  BIN_ARG=FOO # name of the variable with which to override Lisp binary location
#  OPTIONS_ARG=FOO_OPTIONS # name of the variable used above
#  [ -z "$CL_LAUNCH_DEBUG" ] && OPTIONS="${OPTIONS} --option-to-disable-debugger"
#}
implementation_abcl () {
  implementation "${ABCL:-abcl}" || return 1
  OPTIONS="${ABCL_OPTIONS:- --noinform --noinit}" # --nosystem
  EVAL=--eval
  ENDARGS="--"
  IMAGE_ARG=NOT_SUPPORTED_YET
  EXEC_LISP=exec_lisp
  BIN_ARG=ABCL
  OPTIONS_ARG=ABCL_OPTIONS
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    OPTIONS="${OPTIONS} --batch" # -backtrace-on-error ???
  fi
}
__implementation_allegro () {
  OPTIONS="${ALLEGRO_OPTIONS:- -QQ -qq}"
  EVAL=-e
  ENDARGS=--
  IMAGE_ARG=-I
  EXEC_LISP=exec_lisp
  BIN_ARG=ALLEGRO
  OPTIONS_ARG=ALLEGRO_OPTIONS
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    OPTIONS="${OPTIONS} -batch -backtrace-on-error"
  fi
  HASH_BANG_FORM="(setf *readtable* (copy-readtable))${HASH_BANG_FORM}"
}
implementation_allegro () {
  implementation "${ALLEGRO:-alisp}" || return 1
  __implementation_allegro
}
implementation_allegromodern () {
  implementation "${ALLEGROMODERN:-mlisp}" || return 1
  __implementation_allegro
}

implementation_ccl () {
  # ClozureCL, nee OpenMCL, forked from MCL, formerly Macintosh Common Lisp, nee Coral Common Lisp
  implementation "${CCL:-ccl}" || return 1
  OPTIONS="${CCL_OPTIONS:- --no-init --quiet}"
  EVAL=--eval # -e
  # IMAGE_ARG=--image-name # -I
  IMAGE_ARG=EXECUTABLE_IMAGE # depends on our using :prepend-kernel t
  ENDARGS=--
  # (finish-output) is essential for ccl, that won't do it by default,
  # unlike the other lisp implementations tested.
  EXEC_LISP=exec_lisp
  # exec_lisp will work great for 1.1 and later.
  # For earlier versions, use exec_lisp_arg instead:
  # 1.0 doesn't support --, and the latest 1.1-pre060826 snapshot has a bug
  # whereby it doesn't stop at -- when looking for a -I or --image-file argument.
  STANDALONE_EXECUTABLE=t
  BIN_ARG=CCL
  OPTIONS_ARG=CCL_OPTIONS
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    OPTIONS="${OPTIONS} --batch"
  fi
}
implementation_clisp () {
  implementation "${CLISP:-clisp}" || return 1
  OPTIONS="${CLISP_OPTIONS:- -norc --quiet --quiet}"
  EVAL=-x
  LOAD=-i
  ENDARGS="--"
  # if the first argument begins with - there might be problems,
  # so we avoid that and take the cdr or ext:*args*
  # IMAGE_ARG=-M # for use without :executable t
  IMAGE_ARG="EXECUTABLE_IMAGE" # we don't use this by default
  STANDALONE_EXECUTABLE=t # will mostly work as of clisp 2.48, but with a (in)security backdoor.
  # For details, see the thread at http://sourceforge.net/forum/message.php?msg_id=5532730
  EXEC_LISP=exec_lisp
  BIN_ARG=CLISP
  OPTIONS_ARG=CLISP_OPTIONS
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    OPTIONS="${OPTIONS} -on-error exit"
  else
    OPTIONS="${OPTIONS} -on-error debug"
  fi
}
implementation_cmucl () {
  implementation "${CMUCL:-cmucl}" || return 1
  OPTIONS="${CMUCL_OPTIONS:- -quiet -noinit}"
  EVAL=-eval
  ENDARGS=--
  #IMAGE_ARG=-core
  IMAGE_ARG="EXECUTABLE_IMAGE"
  STANDALONE_EXECUTABLE=t
  EXEC_LISP=exec_lisp # depends on a recent CMUCL. Works with 20B.
  BIN_ARG=CMUCL
  OPTIONS_ARG=CMUCL_OPTIONS
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    OPTIONS="${OPTIONS} -batch"
  fi
}
implementation_ecl () {
  implementation "${ECL:-ecl}" || return 1
  OPTIONS="${ECL_OPTIONS:- -q -norc}"
  EVAL=-eval
  ENDARGS=--
  #IMAGE_ARG="-q -load" # for :fasl
  IMAGE_ARG="EXECUTABLE_IMAGE" # for :program
  STANDALONE_EXECUTABLE=t
  BIN_ARG=ECL
  OPTIONS_ARG=ECL_OPTIONS
  EXEC_LISP=exec_lisp
  if [ -n "$CL_LAUNCH_DEBUG" ] ; then
    PROGN="(handler-bind((error'invoke-debugger))(progn(set'si::*break-enable*'t)"
    NGORP="))"
  fi
}
implementation_ecl_bytecodes () {
  implementation_ecl
  OPTIONS="${ECL_OPTIONS:- -q -norc}"
  OPTIONS="${OPTIONS} -eval (ext::install-bytecodes-compiler)"
  EVAL=-eval
  ENDARGS=--
  #IMAGE_ARG="-q -load" # for :fasl
  IMAGE_ARG="EXECUTABLE_IMAGE" # for :program
  STANDALONE_EXECUTABLE=t
  BIN_ARG=ECL
  OPTIONS_ARG=ECL_OPTIONS
  EXEC_LISP=exec_lisp
  if [ -n "$CL_LAUNCH_DEBUG" ] ; then
    PROGN="(handler-bind((error'invoke-debugger))(progn(set'si::*break-enable*'t)"
    NGORP="))"
  fi
}
implementation_mkcl () { ### Untested
  implementation "${MKCL:-mkcl}" || return 1
  OPTIONS="${MKCL_OPTIONS:- -q -norc}"
  EVAL=-eval
  ENDARGS=--
  #IMAGE_ARG="-q -load" # for :fasl
  IMAGE_ARG="EXECUTABLE_IMAGE" # for :program
  STANDALONE_EXECUTABLE=t
  BIN_ARG=ECL
  OPTIONS_ARG=ECL_OPTIONS
  EXEC_LISP=exec_lisp
  if [ -n "$CL_LAUNCH_DEBUG" ] ; then
    PROGN="(handler-bind((error'invoke-debugger))(progn(set'si::*break-enable*'t)" ## Check this one!
    NGORP="))"
  fi
}
implementation_gcl () {
  implementation "${GCL:-gcl}" || return 1
  OPTIONS="${GCL_OPTIONS}"
  EVAL=-eval
  ENDARGS=-- # -f ?n
  IMAGE_ARG=EXECUTABLE_IMAGE
  BIN_ARG=GCL
  OPTIONS_ARG=GCL_OPTIONS
  export GCL_ANSI=t
  EXEC_LISP=exec_lisp
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    OPTIONS="${OPTIONS} -batch"
  fi
}
implementation_lispworks () { ### NOT EXTENSIVELY TESTED
  # http://www.lispworks.com/documentation/lw70/LW/html/lw-203.htm
  USE_CLBUILD= implementation "${LISPWORKS:-lispworks-console}" || return 1
  OPTIONS="${LISPWORKS_OPTIONS:- -siteinit - -init -}" #
  # As of 7.0.0, LispWorks (still) fails to stop processing arguments with "--" or any marker.
  # Therefore we can't "just" tuck arguments at the end of a command-line, and instead we use
  # exec_lisp_file to create a script that initializes arguments and pass that to LispWorks.
  # Since we don't use -eval, we use -build instead of -load to load the script. LispWorks
  # calls all the -eval and -load in order, then the -siteinit, -init and finally -build.
  # It's OK that we use -build, because using it eschews starting the graphical environment
  # and initialization files even on a graphical image, and quits at the end;
  # that should be redundant with the fact that even if using -load, cl-launch should quit
  # before LispWorks gets to start a graphical environment, anyway.
  EVAL=-eval # LOAD=-load EXEC_LISP=exec_lisp ENDARGS="--" ### FAIL by lack of ENDARGS
  LOAD=-build EXEC_LISP=exec_lisp_file ENDARGS=
  IMAGE_ARG="EXECUTABLE_IMAGE" # we don't use this by default
  STANDALONE_EXECUTABLE=t
  BIN_ARG=LISPWORKS
  OPTIONS_ARG=LISPWORKS_OPTIONS
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    : # OPTIONS="${OPTIONS} ..."
  else
    : # OPTIONS="${OPTIONS} ..."
  fi
  export LWLICENSE=$(dirname $LISP_BIN)/lwlicense
}
implementation_sbcl () {
  implementation "${SBCL:-sbcl}" || return 1
  OPTIONS="${SBCL_OPTIONS:- --noinform --userinit /dev/null}"
  # We purposefully specify --userinit /dev/null but NOT --sysinit /dev/null
  EVAL=--eval # SBCL's eval can only handle one form per argument.
  ENDARGS=--end-toplevel-options
  IMAGE_ARG="EXECUTABLE_IMAGE" # we use executable images
  # if you want to test non-executable images, uncomment the one below,
  # and comment out the :executable t in (defun dump-image ...)
  # -IMAGE_ARG=--core
  STANDALONE_EXECUTABLE=t # requires sbcl 1.0.21.24 or later.
  EXEC_LISP=exec_lisp
  BIN_ARG=SBCL
  OPTIONS_ARG=SBCL_OPTIONS
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    OPTIONS="${OPTIONS} --disable-debugger"
  fi
}
implementation_scl () {
  implementation ${SCL:=scl} || return 1
  OPTIONS="${SCL_OPTIONS:- -quiet -noinit}"
  EVAL=-eval
  ENDARGS=--
  IMAGE_ARG=-core
  EXEC_LISP=exec_lisp
  BIN_ARG=SCL
  OPTIONS_ARG=SCL_OPTIONS
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    OPTIONS="${OPTIONS} -batch"
  fi
}
implementation_xcl () {
  implementation "${XCL:-xcl}" || return 1
  OPTIONS="${XCL_OPTIONS:- --noinform --no-userinit}" # --no-siteinit
  EVAL=--eval
  ENDARGS="--"
  IMAGE_ARG=NOT_SUPPORTED_YET
  EXEC_LISP=exec_lisp
  BIN_ARG=XCL
  OPTIONS_ARG=XCL_OPTIONS
  if [ -z "$CL_LAUNCH_DEBUG" ] ; then
    : # Not supported yet
  fi
}
prepare_arg_form () {
  ENDARGS= F=
  for arg ; do
    F="$F\"$(kwote "$arg")\""
  done
  MAYBE_PACKAGE_FORM=" $PACKAGE_FORM"
  LAUNCH_FORMS="(setf uiop/image::*command-line-arguments*'($F))${LAUNCH_FORMS}"
}
# Aliases
implementation_alisp () {
  implementation_allegro "$@"
}
implementation_mlisp () {
  implementation_allegromodern "$@"
}
implementation_gclcvs () {
  implementation "${GCLCVS:=gclcvs}" || return 1
  GCL="$GCLCVS"
  implementation_gcl "$@" && BIN_ARG=GCLCVS
}
implementation_lisp () {
  implementation ${CMULISP:=lisp} || return 1
  CMUCL=$CMULISP
  implementation_cmucl "$@"
}
implementation_openmcl () {
  implementation "${OPENMCL:=openmcl}" || return 1
  CCL="$OPENMCL"
  CCL_OPTIONS="$OPENMCL_OPTIONS"
  implementation_ccl "$@" && BIN_ARG=OPENMCL
}

exec_lisp_noarg () {
  prepare_arg_form "$@"
  exec_lisp
}
exec_lisp_file () {
  prepare_arg_form "$@"
  LOADFILE=${TMPDIR:-/tmp}/cl-load-file-$(date +%s)-$$
  cat > $LOADFILE <<END
${MAYBE_PACKAGE_FORM}
${HASH_BANG_FORM}
${LAUNCH_FORMS}
END
  $LISP_BIN $IMAGE_OPT $IMAGE $OPTIONS $LOAD "$LOADFILE"
  RET=$?
  rm -f $LOADFILE
  exit $RET
}
implementation_clisp_noarg () {
  implementation_clisp
  EXEC_LISP=exec_lisp_noarg
  # For testing purposes
}
implementation_clisp_file () {
  implementation_clisp
  EXEC_LISP=exec_lisp_file
  # For testing purposes
}
implementation () {
  if [ -n "$USE_CLBUILD" ] ; then
    if CLBUILD_BIN="`which clbuild 2> /dev/null`" ; then
      LISP_BIN="$CLBUILD_BIN --implementation $IMPL lisp"
      return 0
    else
      return 1
    fi
  elif [ -x "$1" ] ; then
    LISP_BIN="$1"
    return 0
  elif LISP_BIN="`which "$1" 2> /dev/null`" ; then
    return 0
  else
    return 1
  fi
}
trylisp () {
  IMPL="$1" ; shift
  implementation_${IMPL} "$@"
}
do_exec_lisp () {
  if [ -n "$IMAGE" ] ; then
    if [ "x$IMAGE_ARG" = xEXECUTABLE_IMAGE ] ; then
      LISP_BIN= IMAGE_OPT=
    else
      IMAGE_OPT="$IMAGE_ARG"
    fi
  fi
  $EXEC_LISP "$@"
}
no_implementation_found () {
  ABORT "$PROG: Cannot find a supported lisp implementation.
Tried the following: $*"
}
ensure_implementation () {
  trylisp "$1" || no_implementation_found "$1"
}
try_all_lisps () {
  for l in $LISP $LISPS ; do
    if trylisp $l ; then
      $DO_LISP "$@"
      return 0
    fi
  done
  no_implementation_found "$LISP $LISPS"
}
exec_lisp () {
  # SBCL wants only one form per --eval so we need put everything in one progn.
  # However we also want any in-package form to be evaluated before any of the
  # remaining forms is read, so we get it to be evaluated at read-time as the
  # first thing in the main progn.
  # GNU clisp allows multiple forms per -x but prints the result of every form
  # evaluated and so we also need put everything in a single progn, and that progn
  # must quit before it may return to the clisp frame that would print its value.
  # CMUCL allows multiple forms per -eval and won't print values, so is ok anyway.
  # I don't know about other Lisps, but they will all work this way.
  LAUNCH_FORM="${PROGN}${MAYBE_PACKAGE_FORM}${HASH_BANG_FORM}${LAUNCH_FORMS}${NGORP}"
  ### This is partial support for CLBUILD.
  if [ -n "$USE_CLBUILD" ] ; then
    if [ -z "$IMAGE_OPT" ] ; then
      OPTIONS=
    else
      ABORT "Cannot use clbuild with a non-executable image different from clbuild's"
    fi
  fi
  if [ -n "$CL_LAUNCH_VERBOSE" ] ; then set -x ; fi
  exec $LISP_BIN $IMAGE_OPT $IMAGE $OPTIONS $EVAL "$LAUNCH_FORM" $ENDARGS "$@"
}
launch_self () {
  LAUNCH_FORMS="$(load_form "$PROG")"
  try_all_lisps "$@"
}
invoke_image () {
  if [ "x$IMAGE_ARG" = xEXECUTABLE_IMAGE ] ; then
    LISP_BIN= IMAGE_OPT=
  else
    IMAGE_OPT="$IMAGE_ARG"
  fi
  PACKAGE_FORM=
  HASH_BANG_FORM=
  LAUNCH_FORMS="(uiop:restore-image)"
  "$EXEC_LISP" "$@"
}

export CL_LAUNCH_PID=$$
export CL_LAUNCH_FILE="$PROG"

## execute configuration-provided code
eval "$WRAPPER_CODE"

### END OF CL-LAUNCH SHELL WRAPPER


launch_self "$@"
ABORT
# |#
#+xcvb (module (:build-depends-on () :depends-on ("/asdf")))
#| ;;; cl-launch 4.1.4 lisp header

|# ;;;; Silence our lisp implementation for quiet batch use...

#| We'd like to evaluate as little as possible of the code without compilation.
 This poses a typical bootstrapping problem: the more sophistication we want
 to distinguish what to put where in what dynamic environment, the more code
 we have to evaluate before we may actually load compiled files. And, then,
 it is a waste of time to try to compile said code into a file. Moving things
 to the shell can only help so much, and reduces flexibility. Our best bet is
 to tell sbcl or cmucl to not try to optimize too hard.
|#
#-cl-launch
(eval-when (:compile-toplevel :load-toplevel :execute)
  ;; Configure the printer
  (setf *print-readably* nil ; allegro 5.0 may bork without this
        *print-level* nil)
  ;; Hush the compiler and loader.
  (setf *load-verbose* nil *compile-verbose* nil *compile-print* nil *load-print* nil)
  ;; The code below exemplifies how to try super-hard to load ASDF 3 from standard locations,
  ;; by trying nice methods first, then increasingly desperate ones.
  ;; Stage 1 is to load ASDF at all.
  ;; Stage 2 is to upgrade to whichever ASDF installation the user has configured (if any).
  ;; Versions older than ASDF 3.1 need to be told about ~/common-lisp/
  ;; ASDF 1 has no output translation layer, so can be configured to load ASDF 3
  ;; only if ASDF 3 is in a predictable place under the user's homedir, thus
  ;; ~/common-lisp/asdf/ or ~/.local/share/common-lisp/source/asdf/ only.
  (block nil
    (let ((required-asdf-version  "3.1.2")
          (verbose *load-verbose*))
      (labels ((asdf-symbol (name)
                 (and (find-package :asdf) (find-symbol (string name) :asdf)))
               (asdf-call (name &rest args)
                 (apply (asdf-symbol name) args))
               (asdf-version ()
                 (when (find-package :asdf)
                   (or (symbol-value (or (asdf-symbol '*asdf-version*)
                                         (asdf-symbol '*asdf-revision*)))
                       "1.0")))
               (maybe-display (message)
                 (when (and verbose message) (format t "~&~A~%" message)))
               (call-maybe-verbosely (message function &rest args)
                 (cond
                   (verbose
                    (maybe-display message)
                    (apply function args))
                   (t
                    #+abcl ;; Bug in ABCL 1.3.0: without this, loading asdf.fasl shows warnings
                    (let* ((uc (asdf-symbol '*uninteresting-conditions*))
                           (vars (when uc (list uc)))
                           (vals (when uc (list (cons 'warning (symbol-value uc))))))
                      (progv vars vals
                        (handler-bind ((warning #'muffle-warning))
                          (apply function args))))
                    #-abcl
                    (handler-bind ((warning #'muffle-warning))
                      (apply function args)))))
               (try-stage-1 (message function)
                 (ignore-errors
                  (call-maybe-verbosely (format nil "Trying to ~A" message) function))
                 (maybe-done-stage-1))
               (subpath (parent &key directory name type)
                 (merge-pathnames (make-pathname :defaults parent :name name :type type :version nil
                                                 :directory (cons :relative directory))
                                  parent))
               (build/asdf.lisp (x) (subpath x :directory '("build") :name "asdf" :type "lisp"))
               (visible-default-user-asdf-directory ()
                 (subpath (user-homedir-pathname) :directory '("common-lisp" "asdf")))
               (visible-default-user-asdf-lisp ()
                 (build/asdf.lisp (visible-default-user-asdf-directory)))
               (hidden-default-user-asdf-directory ()
                 (subpath (user-homedir-pathname) :directory '(".local" "share" "common-lisp" "asdf")))
               (hidden-default-user-asdf-lisp ()
                 (build/asdf.lisp (hidden-default-user-asdf-directory)))
               (try-file-stage-1 (name explanation base root sub)
                 (try-stage-1
                  (format nil "load ASDF from ~A/ under the ~A CL source directory ~A~{~A/~}"
                          name explanation root sub)
                  #'(lambda () (load (build/asdf.lisp
                                      (subpath base :directory (append sub (list name))))))))
               (stage-1 () ;; Try to load ASDF at all, any ASDF.
                 (try-stage-1
                  ;; Do nothing if ASDF is already loaded
                  "use an already loaded ASDF"
                  (constantly nil))
                 (try-stage-1
                  "require ASDF from the implementation"
                  ;; Most implementations provide ASDF, but while most of them are case-insensitive,
                  ;; CLISP is case-sensitive, so we need to specify a lowercase string,
                  ;; and not the keyword :asdf or symbol 'asdf.
                  ;; All recent implementations provide ASDF 3,
                  ;; but older variants in the wild may only provide ASDF 2 or even ASDF 1.
                  #'(lambda () (funcall 'require "asdf")))
                 (try-file-stage-1 "asdf" "default (visible)" (user-homedir-pathname)
                                   "~/" '("common-lisp"))
                 (try-file-stage-1 "asdf" "default (hidden)" (user-homedir-pathname)
                                   "~/" '(".local" "share" "common-lisp"))
                 #+(or unix linux bsd darwin)
                 (progn
                   (loop :for (name path) :in '(("local system" ("local")) ("managed system" ()))
                         :do (loop :for sub :in '(() ("source"))
                                   :do (try-file-stage-1
                                        "asdf" name #p"/" "/"
                                        (append '("usr") path '("share" "common-lisp") sub))))
                   (try-file-stage-1 "cl-asdf" "managed system" #p"/" "/"
                                     '("usr" "share" "common-lisp" "source")))
                 (error "Could not load ASDF."))
               (maybe-done-stage-1 ()
                 ;; If we have ASDF, then go to stage 2: have it upgrade itself.
                 (when (member :asdf *features*)
                   (maybe-display (format nil "Found ASDF ~A" (asdf-version)))
                   (stage-2))) ;; doesn't return.
               (centrally-register (path)
                 (let ((r (asdf-symbol '*central-registry*)))
                   (pushnew path (symbol-value r))
                   (pushnew (subpath path :directory '("uiop")) (symbol-value r))))
               (configure-asdf ()
                 ;; configure older versions of ASDF, as needed
                 (cond
                   ((probe-file (visible-default-user-asdf-lisp))
                    (unless (member :asdf3.1 *features*)
                      (maybe-display "Telling this old ASDF about your ~/common-lisp/asdf/")
                      (centrally-register (visible-default-user-asdf-directory))))
                   ((probe-file (hidden-default-user-asdf-lisp))
                    (unless (member :asdf2 *features*)
                      (maybe-display "Telling this antique ASDF about your ~/.local/share/common-lisp/asdf/")
                      (centrally-register (hidden-default-user-asdf-directory))))))
               (maybe-done-stage-2 ()
                 (when (ignore-errors (asdf-call 'version-satisfies
                                                 (asdf-version) required-asdf-version))
                   (when verbose
                     (format t "~&Victory! We now have ASDF ~A~%" (asdf-version)))
                   (return)))
               (stage-2 ()
                 ;; We have ASDF, now have it upgrade itself.
                 (configure-asdf)
                 (when (asdf-call 'find-system :asdf nil)
                   (call-maybe-verbosely
                    "Trying to upgrade ASDF"
                    (asdf-symbol 'operate) (asdf-symbol 'load-op) :asdf) :verbose nil)
                 (maybe-done-stage-2)
                 (error "We could only load ASDF ~A but we need ASDF ~A"
                        (asdf-version) required-asdf-version)))
        ;; :asdf3.1 is both more recent than required and self-upgrading, so doesn't need this dance
        ;; :asdf3 is self-upgrading but might not be recent enough (it could be a pre-release).
        (unless (member :asdf3.1 *features*)
          (call-maybe-verbosely nil #'stage-1)))))

  (in-package :asdf))
#-cl-launch
;; Because of ASDF upgrade punting, this ASDF package may be a new one.
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (or #+asdf3 (uiop:version<= "3.1.2" (asdf:asdf-version)))
    (error "cl-launch requires ASDF 3.1.2 or later")))
#-cl-launch
;;;; Create cl-launch with UIOP.
(progn
(uiop:define-package :cl-launch
  (:use :common-lisp :uiop :asdf)
  (:export #:compile-and-load-file))

(in-package :cl-launch))
#-cl-launch
;;;; cl-launch initialization code
(progn
(defvar *cl-launch-header* nil) ;; name of the file with this Lisp header (if any)
(defvar *cl-launch-file* nil) ;; name of the file with the user code (if any)
(defvar *verbose* nil)
(defun dump-stream-to-file (i n)
  (with-output-file (o n :if-exists :rename-and-delete) (copy-stream-to-stream i o)))
(defun dump-sexp-to-file (x n)
  (with-output-file (o n :if-exists :rename-and-delete) (write x :stream o :pretty t :readably t)))
(defvar *temporary-filenames* nil)
(defvar *temporary-file-prefix*
  (native-namestring (subpathname *temporary-directory*
                                  (strcat "cl-launch-" (getenvp "CL_LAUNCH_PID")))))
(defun make-temporary-filename (x)
  (parse-native-namestring (strcat *temporary-file-prefix* x)))
(defun register-temporary-filename (n)
  (push n *temporary-filenames*)
  n)
(defun temporary-filename (x)
  (register-temporary-filename (make-temporary-filename x)))
(defun temporary-file-from-foo (dumper arg x)
  (let ((n (temporary-filename x)))
    (funcall dumper arg n)
    n))
(defun temporary-file-from-stream (i x)
  (temporary-file-from-foo #'dump-stream-to-file i x))
(defun temporary-file-from-string (i x)
  (temporary-file-from-foo
   #'(lambda (i n) (with-output-file (o n :if-exists :rename-and-delete) (princ i o))) i x))
(defun temporary-file-from-sexp (i x)
  (temporary-file-from-foo #'dump-sexp-to-file i x))
(defun temporary-file-from-code (i x)
  (if (stringp i)
      (temporary-file-from-string i x)
      (temporary-file-from-sexp i x)))
(defun temporary-file-from-file (f x)
  (with-open-file (i f :direction :input :if-does-not-exist :error)
    (temporary-file-from-stream i x)))
(defun ensure-lisp-file-name (x &optional (name "load.lisp"))
  (if (equal (pathname-type x) "lisp") x (temporary-file-from-file x name)))
(defun ensure-lisp-loadable (x)
  (cond
    ((eq x t) (ensure-lisp-loadable (or *cl-launch-file* (error "Missing CL_LAUNCH_FILE"))))
    ((equal x "-") *standard-input*)
    ((or (streamp x) (pathnamep x)) x)
    ((stringp x) (ensure-absolute-pathname (parse-native-namestring x) #'getcwd))))
(defun ensure-lisp-file (x &optional (name "load.lisp"))
  (let ((x (ensure-lisp-loadable x)))
    (etypecase x
      (stream (temporary-file-from-stream x name))
      (pathname (ensure-lisp-file-name x name)))))
(defun cleanup-temporary-files ()
  (loop :for n = (pop *temporary-filenames*)
        :while n :do
          (delete-file-if-exists n)))
(defun file-newer-p (new-file old-file)
  "Returns true if NEW-FILE is strictly newer than OLD-FILE."
  (> (file-write-date new-file) (file-write-date old-file)))
(defun compile-and-load-file (source &key force-recompile
                              (verbose *verbose*) (load t)
                              output-file)
  "compiles and load specified SOURCE file, if either required by keyword
argument FORCE-RECOMPILE, or not yet existing, or not up-to-date.
Keyword argument VERBOSE specifies whether to be verbose.
Returns two values: the fasl path, and T if the file was (re)compiled"

  ;; When in doubt, don't trust - recompile. Indeed, there are
  ;; edge cases cases when on the first time of compiling a simple
  ;; auto-generated file (e.g. from the automated test suite), the
  ;; fasl ends up being written to disk within the same second as the
  ;; source was produced, which cannot be distinguished from the
  ;; reverse case where the source code was produced in the same split
  ;; second as the previous version was done compiling. Could be
  ;; tricky if a big system needs be recompiled as a dependency on an
  ;; automatically generated file, but for cl-launch those
  ;; dependencies are not detected anyway (BAD). If/when they are, and
  ;; lacking better timestamps than the filesystem provides, you
  ;; should sleep after you generate your source code.
  (let* (#+gcl
         (maybe-delete
           (unless (equal (pathname-type source) "lisp")
             (let ((temp (make-temporary-filename (strcat (pathname-name source) ".lisp"))))
               (copy-file source temp)
               (setf source temp))))
         (truesource (truename source))
         (fasl (or output-file (compile-file-pathname* truesource)))
         (compiled-p
          (when (or force-recompile
                    (not (probe-file fasl))
                    (not (file-newer-p fasl source)))
            (ensure-directories-exist fasl)
            (multiple-value-bind (path warnings failures)
                (compile-file* truesource :output-file fasl)
              (declare (ignorable warnings failures))
              (unless (equal (truename fasl) (truename path))
                (error "cl-launch: file compiled to ~A, expected ~A" path fasl))
              (when failures
                (error "cl-launch: failures while compiling ~A" source)))
            t)))
    (when load
      (load* fasl :verbose verbose))
    #+gcl (delete-file-if-exists maybe-delete)
    (values fasl compiled-p)))
(defun load-file (source &key output-file)
  (declare (ignorable output-file))
  #-(or gcl (and ecl (not dlopen)))
  (compile-and-load-file source :verbose *verbose* :output-file output-file)
  #+gcl
  (let* ((pn (parse-namestring source))) ; when compiling, gcl 2.6 will always
    (if (pathname-type pn) ; add a type .lsp if type is missing, to avoid compilation
      (compile-and-load-file source :verbose *verbose* :output-file output-file)
      (load source :verbose *verbose*)))
  #+(and ecl (not dlopen))
  (load source :verbose *verbose*))
(defun compute-arguments ()
  (setf *cl-launch-file* (getenvp "CL_LAUNCH_FILE")
        *cl-launch-header* (getenvp "CL_LAUNCH_HEADER")
        *verbose* (when (getenvp "CL_LAUNCH_VERBOSE") t)))

(asdf::register-preloaded-system "cl-launch")

(defun load-sys (system)
  (if (find-package :quicklisp)
      (let ((*standard-output* (make-broadcast-stream)))
        (symbol-call :quicklisp :quickload system))
      (asdf:load-system system)))

;;; We need this on all implementations when dumping an image,
;;; so that --eval and --file statements may properly depend
;;; on previously loaded systems, etc.
;;; To do it right, though, we want to only create a file
;;; for the --eval statement if needed by ECL...
(defvar *dependency-counter* 0)
(defun cl-launch-files ()
  (when (pathnamep *cl-launch-file*)
    (list *cl-launch-file*)))
(defun make-temporary-system (stem rdeps options)
  ;; Make a temporary system with given name stem and options
  ;; return the new list of dependencies, i.e. a singleton of the actual system name.
  (let ((sys (strcat "cl-launch-" stem)))
    (eval `(handler-bind ((warning #'muffle-warning))
             (defsystem ,sys
               :version "0" :author "cl-launch user" :description "generated by cl-launch"
               :pathname ,*temporary-directory* :depends-on ,(reverse rdeps) ,@options)
             (defmethod input-files ((o operation) (s (eql (find-system ,sys))))
               ',(cl-launch-files))))
    (list sys)))
(defclass asdf::cl-source-file-in-package (cl-source-file)
  ((package :initarg :package :reader component-package)))
(defclass asdf::cl-source-code (source-file)
  ((code :initarg :code :initform nil :reader component-code)
   (package :initarg :package :reader component-package)))
(handler-bind ((warning #'muffle-warning))
  (defmethod perform :around ((o compile-op) (c asdf::cl-source-file-in-package))
    (let ((*package* (find-package (component-package c))))
      (call-next-method)))
  (defmethod component-pathname ((c asdf::cl-source-code)) nil)
  (defmethod perform ((o compile-op) (c asdf::cl-source-code)))
  (defmethod perform ((o load-op) (c asdf::cl-source-code))
    (let ((*package* (find-package (component-package c))))
      (eval-thunk (or (component-code c) (component-name c))))))
(defun make-dependency-system (rdeps options)
  ;; Make a system for given dependencies,
  ;; return the new list of dependencies, i.e. a singleton of the system name.
  (let ((name (format nil "build-~D" *dependency-counter*)))
    (incf *dependency-counter*)
    (make-temporary-system name rdeps options)))
(defun make-dependency (dump fun arg pkg previous)
  ;; Make a dependency, return the new list of dependencies
  (ecase fun
    ((:load)
       (let ((x (ensure-lisp-loadable arg)))
         (if (or (pathnamep x) #+(or ecl mkcl) dump)
           (let ((load-file (ensure-lisp-file x (format nil "load-~D.lisp" *dependency-counter*))))
             (make-dependency-system previous
              `(:components ((:cl-source-file-in-package ,(pathname-name load-file)
                              :package ,pkg :pathname ,(truename load-file))))))
           (make-dependency dump :eval `(load* ,x) pkg previous))))
    ((:eval)
     (if (and #+(or ecl mkcl) (not dump))
       (make-dependency-system previous
        `(:components ((:cl-source-code ,(format nil "eval-~D" *dependency-counter*)
                        :code ,arg :package :cl-user))))
       #+(or ecl mkcl)
       (with-input (i (temporary-file-from-code arg (format nil "eval-~D.lisp" *dependency-counter*)))
         (make-dependency dump :load i :cl-user previous))))
    ((:require)
     (cons `(:require ,arg) previous))
    ((:load-system)
     (cons arg previous))))

(defun build-program (dump build restart final init quit)
  (unwind-protect
       (let* ((*compile-verbose* *verbose*)
              #+ecl (c::*suppress-compiler-warnings* (not *verbose*))
              #+ecl (c::*suppress-compiler-notes* (not *verbose*))
              (standalone (and (getenvp "CL_LAUNCH_STANDALONE") t))
              (op (if standalone 'program-op 'image-op))
              (dependencies
                (loop :with r = ()
                      :for (fun arg pkg) :in
                      `((:load-system "asdf")
                        ,@(when dump ;; do we still want to include cl-launch in the dumped code,
                            #+(or ecl mkcl) ;; now that all the relevant runtime support is in UIOP?
                            (let ((header *cl-launch-header*)) ;; maybe for dependency timestamp?
                              (setf *features* (remove :cl-launch *features*))
                              `((:load ,(ensure-lisp-file header "header.lisp") :cl-user))))
                        ,@build
                        ,(let ((footer
                                 `(setf
                                   *package* (find-package :cl-user)
                                   *image-dumped-p* ,(when dump (if standalone :executable t))
                                   *image-entry-point*
                                   ,(when restart `(ensure-function ,(car restart) :package ,(cdr restart)))
                                   *image-prelude* ,init
                                   *image-postlude* ,final
                                   *lisp-interaction* ,(not quit))))
                           `(:eval ,footer :cl-user)))
                      :do (setf r (make-dependency dump fun arg pkg r))
                      :finally (return r)))
              (program-sys
                (make-temporary-system
                 "program" dependencies
                 `(:serial t
                   :build-operation ,op
                   :build-pathname ,(when dump (ensure-absolute-pathname dump #'getcwd))
                   :entry-point ,(when restart
                                   `(lambda ()
                                      (funcall (ensure-function ,(car restart) :package ,(cdr restart)))))
                   ;; For SBCL and other platforms that die on dump-image, clean before the end:
                   :perform (image-op :before (o c)
                             (setf *features* (remove :cl-launched *features*))
                             (cleanup-temporary-files))))))
         (load-sys program-sys) ;; Give quicklisp a chance to download things
         (when dump
           (operate op program-sys)))
    (cleanup-temporary-files))
  (unless dump
    (restore-image))
  (quit 0))

(defun load-quicklisp ()
  (block nil
    (flet ((try (x) (when (probe-file* x) (return (load* x)))))
      (try (subpathname (user-homedir-pathname) "quicklisp/setup.lisp"))
      (try (subpathname (user-homedir-pathname) ".quicklisp/setup.lisp"))
      (error "Couldn't find quicklisp in your home directory. ~
              Go get it at http://www.quicklisp.org/beta/index.html"))))

(defun run (&key quicklisp source-registry build dump restart final init (quit t))
  (setf *lisp-interaction* (not quit))
  (with-fatal-condition-handler ()
    (pushnew :cl-launched *features*)
    (compute-arguments)
    (when source-registry (initialize-source-registry source-registry))
    (when quicklisp (load-quicklisp))
    (build-program dump build restart final init quit)))

(pushnew :cl-launch *features*))
;;;;; Return to the default package.
(cl:in-package :cl-user)

;;; END OF CL-LAUNCH LISP HEADER


;;;; CL-LAUNCH LISP INITIALIZATION CODE

#-cl-launched
(cl-launch::run :quicklisp t :build '((:load-system "centro")) :restart '("(lambda()(main uiop:*command-line-arguments*))" . :centro))

;;;; END OF CL-LAUNCH LISP INITIALIZATION CODE

